# -*- coding: utf-8 -*-
"""MAJOR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16uE0dD89pH2M1qgmT8Zwcf-JUegxsXwM
"""

!pip install pycryptodome

!pip install stegano

from Crypto.Cipher import Blowfish, PKCS1_OAEP, AES
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad, unpad
from binascii import hexlify , unhexlify
import hashlib , json, string, random
from stegano import lsb
from datetime import datetime

# Key Generator
def key_generator(size, case="default", punctuations="required"):
    if case=="default" and punctuations=="required":
        return ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase + string.digits + string.punctuation, k = size))
    elif case=="upper-case-only" and punctuations=="required":
        return ''.join(random.choices(string.ascii_uppercase + string.digits + string.punctuation, k = size))
    elif case=="lower-case-only"  and punctuations=="required":
        return ''.join(random.choices(string.ascii_lowercase + string.digits + string.punctuation, k = size))
    elif case=="default" and punctuations=="none":
        return ''.join(random.choices(string.ascii_uppercase + string.digits + string.ascii_lowercase, k = size))
    elif case=="lower-case-only"  and punctuations=="none":
        return ''.join(random.choices(string.ascii_lowercase + string.digits , k = size))
    elif case=="upper-case-only" and punctuations=="none":
        return ''.join(random.choices(string.ascii_uppercase + string.digits, k = size))

!pip install python-docx

# with open('/content/mpfile1.docx', 'r') as file:
#     plaintext = file.read()
#     print(plaintext)
from docx import Document

# Load the .docx file
doc = Document('/content/mpfile1.docx')

# Extract text from paragraphs
plaintext = ""
for paragraph in doc.paragraphs:
    plaintext += paragraph.text + "\n"
print(plaintext)

if isinstance(plaintext, str):
    plaintext = plaintext.encode('utf-8')
from binascii import hexlify
log_plaintext_length = len(hexlify(plaintext))

# Password for Keys
password = 'anurag2024' #input('Enter Password: ')
log_password_length = len(password)

log_start_time = datetime.now()

hash = hashlib.sha1()
hash.update(password.encode())
password_encryption_cipher = AES.new( hash.hexdigest()[:16].encode() , AES.MODE_CBC, iv= '16bitAESInitVect'.encode())

password

keys_iv = {}

# Blowfish Layer 1

blowfish_key =  key_generator(size=16).encode()
blowfish_cipher = Blowfish.new(blowfish_key, Blowfish.MODE_CBC)

blowfish_ciphertext = blowfish_cipher.encrypt(pad(plaintext, Blowfish.block_size ))

keys_iv['blowfish_iv'] = hexlify(blowfish_cipher.iv).decode()
keys_iv['blowfish_key'] = hexlify(blowfish_key).decode()

keys_iv

# RSA Layer 2

rsa_key = RSA.generate(2048)
rsa_private_key = rsa_key
rsa_public_key = rsa_key.publickey()

cipher_rsa = PKCS1_OAEP.new(rsa_public_key)
rsa_plaintext = blowfish_ciphertext

rsa_ciphertext = bytearray()
for i in range(0, len(rsa_plaintext), 190):
    rsa_ciphertext.extend(cipher_rsa.encrypt(rsa_plaintext[i:i+190]))

keys_iv['rsa_n'] = rsa_private_key.n
keys_iv['rsa_e'] = rsa_private_key.e
keys_iv['rsa_d'] = rsa_private_key.d

print(rsa_ciphertext)

print(keys_iv)

# AES Layer 3
aes_key =  key_generator(size=16).encode()
aes_cipher = AES.new(aes_key, AES.MODE_CBC)
aes_plaintext = rsa_ciphertext

aes_ciphertext = aes_cipher.encrypt(pad(aes_plaintext, AES.block_size))

ciphertext = aes_ciphertext

print(ciphertext)

with open('/content/mpfile1_enc.docx', 'w') as file:
    file.write(hexlify(ciphertext).decode())

log_ciphertext_length = len(hexlify(ciphertext))

keys_iv['aes_iv'] = hexlify(aes_cipher.iv).decode()
keys_iv['aes_key'] = hexlify(aes_key).decode()


# Encryption of Key and IV String
encrypted_keys_and_iv = hexlify(password_encryption_cipher.encrypt(pad(json.dumps(keys_iv).encode(), AES.block_size)))

encrypted_keys_and_iv

# #LSB Steg
# lsb_stegano_image = lsb.hide("/content/mpimage.jpg", encrypted_keys_and_iv.decode())
# lsb_stegano_image.save("/content/stego1_image.jpg")
# from stegano import lsb
# from PIL import Image

# # Text to hide in the image
# secret_message = encrypted_keys_and_iv

# # Image to hide the text in
# input_image = "/content/mpimage.jpg"

# # Output image with the hidden message
# output_image = "/content/stego1_image.jpg"

# # Hide the text in the image
# lsb.hide(input_image, secret_message).save(output_image)
# lsb_stegano_image = lsb.hide("/content/mpimage.jpg", encrypted_keys_and_iv.decode())
# lsb_stegano_image.save("/content/stego1_image.jpg")
# print("Text successfully hidden in the image.")
# Python program implementing Image Steganography

# PIL module is used to extract
# pixels of image and modify it
from PIL import Image

# Convert encoding data into 8-bit binary
# form using ASCII value of characters
def genData(data):

		# list of binary codes
		# of given data
		newd = []

		for i in data:
			newd.append(format(ord(i), '08b'))
		return newd

# Pixels are modified according to the
# 8-bit binary data and finally returned
def modPix(pix, data):

	datalist = genData(data)
	lendata = len(datalist)
	imdata = iter(pix)

	for i in range(lendata):

		# Extracting 3 pixels at a time
		pix = [value for value in imdata.__next__()[:3] +
								imdata.__next__()[:3] +
								imdata.__next__()[:3]]

		# Pixel value should be made
		# odd for 1 and even for 0
		for j in range(0, 8):
			if (datalist[i][j] == '0' and pix[j]% 2 != 0):
				pix[j] -= 1

			elif (datalist[i][j] == '1' and pix[j] % 2 == 0):
				if(pix[j] != 0):
					pix[j] -= 1
				else:
					pix[j] += 1
				# pix[j] -= 1

		# Eighth pixel of every set tells
		# whether to stop ot read further.
		# 0 means keep reading; 1 means thec
		# message is over.
		if (i == lendata - 1):
			if (pix[-1] % 2 == 0):
				if(pix[-1] != 0):
					pix[-1] -= 1
				else:
					pix[-1] += 1

		else:
			if (pix[-1] % 2 != 0):
				pix[-1] -= 1

		pix = tuple(pix)
		yield pix[0:3]
		yield pix[3:6]
		yield pix[6:9]

def encode_enc(newimg, data):
	w = newimg.size[0]
	(x, y) = (0, 0)

	for pixel in modPix(newimg.getdata(), data):

		# Putting modified pixels in the new image
		newimg.putpixel((x, y), pixel)
		if (x == w - 1):
			x = 0
			y += 1
		else:
			x += 1

# Encode data into image
def encode():
	img = input("Enter image name(with extension) : ")
	image = Image.open(img, 'r')

	data = encrypted_keys_and_iv.decode()
	if (len(data) == 0):
		raise ValueError('Data is empty')

	newimg = image.copy()
	encode_enc(newimg, data)

	new_img_name = input("Enter the name of new image(with extension) : ")
	newimg.save(new_img_name, str(new_img_name.split(".")[1].upper()))

# Decode the data in the image
def decode():
	img = input("Enter image name(with extension) : ")
	image = Image.open(img, 'r')

	data = ''
	imgdata = iter(image.getdata())

	while (True):
		pixels = [value for value in imgdata.__next__()[:3] +
								imgdata.__next__()[:3] +
								imgdata.__next__()[:3]]

		# string of binary data
		binstr = ''

		for i in pixels[:8]:
			if (i % 2 == 0):
				binstr += '0'
			else:
				binstr += '1'

		data += chr(int(binstr, 2))
		if (pixels[-1] % 2 != 0):
			return data

# Main Function
def main():
	a = int(input(":: Welcome to Steganography ::\n"
						"1. Encode\n2. Decode\n"))
	if (a == 1):
		encode()

	elif (a == 2):
		print("Decoded Word : " + decode())
	else:
		raise Exception("Enter correct input")

# Driver Code
if __name__ == '__main__' :

	# Calling main function
	main()


log_end_time = datetime.now()

log_duration = str(log_end_time - log_start_time)

#DECRYPTION

password = 'srm2017' #input('Enter Password: ')

with open('/content/mpfile1_enc.docx', 'r') as file:
    ciphertext = file.read()

hash = hashlib.sha1()
hash.update(password.encode())
password_decryption_cipher = AES.new( hash.hexdigest()[:16].encode() , AES.MODE_CBC, iv= '16bitAESInitVect'.encode())

decrypted_keys_iv = json.loads(unpad(password_decryption_cipher.decrypt(unhexlify(encrypted_keys_and_iv)), AES.block_size))

#Initializations
decryption_key_aes = unhexlify(decrypted_keys_iv['aes_key'])
decryption_iv_aes = unhexlify(decrypted_keys_iv['aes_iv'])
decryption_key_rsa = RSA.construct(rsa_components = (decrypted_keys_iv['rsa_n'] , decrypted_keys_iv['rsa_e'] , decrypted_keys_iv['rsa_d']))
decryption_iv_blowfish = unhexlify(decrypted_keys_iv['blowfish_iv'])
decryption_key_blowfish = unhexlify(decrypted_keys_iv['blowfish_key'])


aes_cipher_decryption = AES.new(decryption_key_aes, AES.MODE_CBC, iv=decryption_iv_aes)
rsa_cipher_decryption = PKCS1_OAEP.new(decryption_key_rsa)
blowfish_cipher_decryption = Blowfish.new(decryption_key_blowfish, Blowfish.MODE_CBC, iv=decryption_iv_blowfish)
import re

# AES DECRYPTION
ciphertext_rsa = unpad(aes_cipher_decryption.decrypt(unhexlify(ciphertext)), AES.block_size)

# RSA DECRYPTION
ciphertext_blowfish = bytearray()
for i in range(0, len(ciphertext_rsa), 256):
    ciphertext_rsa_segment = ciphertext_rsa[i:i+256]
    ciphertext_blowfish.extend(rsa_cipher_decryption.decrypt(ciphertext_rsa_segment))

# BLOWFISH DECRYPTION
decrypted_plaintext_bytes = unpad(blowfish_cipher_decryption.decrypt(ciphertext_blowfish), Blowfish.block_size)

# Decode bytes to string
decrypted_plaintext = decrypted_plaintext_bytes.decode('utf-8')

# Remove non-printable ASCII characters
decrypted_plaintext = re.sub(r'[^\x20-\x7E]', '', decrypted_plaintext)

print(decrypted_plaintext)
# log_end_time = datetime.now()
# log_duration = str(log_end_time - log_start_time)
# log_plaintext_length = len(hexlify(decrypted_plaintext))

# with open('./content/decryption-log.txt', 'a+') as log_file:
#     log_file.write( "\n| "   +str(log_ciphertext_length)
#                    +"          | "+str(log_plaintext_length)
#                    +"          | "+str(log_password_length)
#                    +"         | "+log_start_time.strftime("%H:%M:%S")
#                    +"   | "+log_end_time.strftime("%H:%M:%S")
#                    +"  | "+str(log_duration)
#                    +" |"
#                   )

with open('./content/mpfile1_dec.txt', 'wb') as file:
    file.write(decrypted_plaintext)

#print("Decrypted Ciphertext: ", decrypted_plaintext.decode())
print('File Decryption Complete!')

decrypted_plaintext

import cv2
import numpy as np

def calculate_psnr(image1, image2):
    # Convert images to float32
    image1 = image1.astype(np.float32)
    image2 = image2.astype(np.float32)

    # Calculate MSE
    mse = np.mean(np.square(image1 - image2))

    # Calculate PSNR
    if mse == 0:
        psnr = float('inf')
    else:
        max_pixel = 255.0
        psnr = 20 * np.log10(max_pixel / np.sqrt(mse))

    return psnr, mse

# Example usage
# Load original and reconstructed images
original_image = cv2.imread('/content/bell.png')
reconstructed_image = cv2.imread('/content/bell-re.png')

# Calculate PSNR and MSE
psnr_value, mse_value = calculate_psnr(original_image, reconstructed_image)

# Print PSNR and MSE values
print("PSNR:", psnr_value, "dB")
print("MSE:", mse_value)